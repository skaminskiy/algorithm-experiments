Quicksort sorts n numbers in place, but its worst-case running
time is Big Theta(n2). Its expected running time is Big Theta(nlgn), however, and it generally
outperforms heapsort in practice. Like insertion sort, quicksort has tight code, and
so the hidden constant factor in its running time is small. It is a popular algorithm
for sorting large input arrays.
Despite this slow worst-case running time, quicksort is often the best
practical choice for sorting because it is remarkably efficient on the average: its
expected running time is Big Theta(nlgn), and the constant factors hidden in the Big Theta(nlgn)
notation are quite small. It also has the advantage of sorting in place,
and it works well even in virtual-memory environments.

Insertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they
determine the sorted order of an input array by comparing elements. Chapter 8 begins
by introducing the decision-tree model in order to study the performance limitations
of comparison sorts. Using this model, we prove a lower bound of Big Omega(nlgn)
on the worst-case running time of any comparison sort on n inputs, thus showing
that heapsort and merge sort are asymptotically optimal comparison sorts.

We can beat this lower bound of Big Omega(nlgn)
if we can gather information about the sorted order of the input by means other
than comparing elements: counting sort algorithm, radix sort algorithm, bucket sort algorithm.

